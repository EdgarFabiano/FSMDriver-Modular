\section{Background}

The Simulated Car Racing Championship (SCR) is a well-known event comprising 
three sequential competitions held in association with \textit{IEEE}, and 
present in well known conferences such as the \textit{Congress on Evolutionary 
Computation} (CEC), \textit{ACM Genetic and Evolutionary Computational Conference} 
(GECCO) and the \textit{Symposium on Computational Intelligence and Games} 
(CIG)~\cite{scr2009}.  It provides an opportunity for the scientific community 
to perform a straightforward comparison among different approaches in complex 
environments containing multiple continuous variables~\cite{caldeira_2013}. For 
this, it uses \emph{The Open Car Racing Simulator}, a state-of-the art car simulator. 

\subsection{The Open Car Racing Simulator}
TORCS provides a very customizable environment, sophisticated 3D graphics, and -
most importantly - a powerful physics simulation platform~\cite{manual}. Its 
physics engine considers static and dynamic aspects, such as fuel usage, damage 
received, wheel traction, and others, in a very detailed way. Thus, it enables 
a very complex environment for testing AI techniques.

TORCS serves both as a research platform for AI on racing development and as an 
ordinary car racing game. The main reason why TORCS is widespread in the AI gaming 
universe is its portability; it runs on all \textit{Linux}'s architectures,
\textit{FreeBSD}, \textit{OpenSolaris}, \textit{MacOSX} and both 32 and 64 bits 
\textit{Windows}. TORCS has its own online community, which started its own 
racing competitions some years ago~\cite{TORCS}, where developers can submit 
their controllers to compete with each other.


\subsection{The Simulated Car Racing Championship}
The SCR contest provides a standard measure for TORCS controllers by defining strict
rules, based on the Formula 1 score system~\cite{scr2009}. It improves on the 
practical applications aspects by limiting the controller's knowledge of 
the system to the information provided by its inputs and its actions by its outputs,
much like an actual autonomous vehicle.

The interface provides with a diversified set of sensors, such as the current 
position of the car in the track, its acceleration and brake values, and so on~\cite{scr2009}. 
The information provided by them defines the controllers perception of its environment (track, other controllers, etc.), and the idea is to program a behavior that results
in the best possible race. 

\subsection{SCR Contestants}
Works submitted to SCR have a wide range of variety, going from sophisticated 
heuristic designs to completely mathematical and statistical approaches. The 
controller that won the 2009 Simulated Car Racing Championship,~\cite{scr2009}
perhaps one of the most important editions realized so far, was created by 
Onieva et al.~\cite{onieva_2009}, and it 
consists of a simple set of controllers in an \emph{modular configuration}. 

Although this controller won the competition, the authors noted that it evolved 
into a fairly complex model and noted that a modular approach considerably reduce 
the effort to implement a  controller. Refactoring and debugging such a complex 
architecture requires changing code that is not directly related to the desired
change in behavior.

Another interesting controller used  artificial neural networks~\cite{cardamone_2010},
a more general approach which required little domain knowledge and provided a 
satisfactory result. Also in this case,  the implementation is quite complex and 
the final result manages connections between all inputs and outputs.

In order to reduce the effort in developing a controller, a more modular approach,
such as a \emph{finite state machine}, is desireable.

\subsection{Finite State Machines}\label{sec:fsm}

\emph{Finite State Machines} (FSM), \emph{Finite-State Automaton}, or even the 
simple \emph{State Machine}, are designations of the same model. They all 
describe a mathematical model of computation used in computer programs, such as 
this one, and also in sequential logic circuits. FSM has a typical \textit{abstract machine} behavior,
with a limited number of states, and, by definition, can be only and exclusively in one of these states at a time. The 
state in which the machine is in a present/defined moment will be hereby called the \emph{current state}, as a matter
of convenience. The machine changes its current state when triggered by a pre-defined event (a \emph{transition}).

% Thus, a FSM is a model defined by states, which the \textit{current state} is changed every time a \textit{transition}
% defined by the designated conditions is triggered. According to Mat Buckland's definition published inside 
% \emph{Programming Game AI by Example}~\cite{buckland2005}, 
% ``\emph{A finite state machine is a device, or a model
%	of a device, which has a finite number of states it can be in at any given time and can operate on	input to either 
%	make transitions from one state to another or to cause an output or action to take place. A finite state machine can
%	only be in one	state at any moment in time.}''\\[0.2cm]